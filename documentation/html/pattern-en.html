<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>pattern-en</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link type="text/css" rel="stylesheet" href="../clips.css" />
    <style>
        /* Small fixes because we omit the online layout.css. */
        h3 { line-height: 1.3em; }
        #page { margin-left: auto; margin-right: auto; }
        #header, #header-inner { height: 175px; }
        #header { border-bottom: 1px solid #C6D4DD;  }
        table { border-collapse: collapse; }
    </style>
    <link href="../js/shCore.css" rel="stylesheet" type="text/css" />
    <link href="../js/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <script language="javascript" src="../js/shCore.js"></script>
    <script language="javascript" src="../js/shBrushXml.js"></script>
    <script language="javascript" src="../js/shBrushJScript.js"></script>
    <script language="javascript" src="../js/shBrushPython.js"></script>
</head>
<body class="node-type-page one-sidebar sidebar-right section-pages">
    <div id="page">
    <div id="page-inner">
    <div id="header"><div id="header-inner"></div></div>
    <div id="content">
    <div id="content-inner">
    <div class="node node-type-page"
        <div class="node-inner">
        <div class="breadcrumb">View online at: <a href="http://www.clips.ua.ac.be/pages/pattern-en" class="noexternal" target="_blank">http://www.clips.ua.ac.be/pages/pattern-en</a></div>
        <h1>pattern.en</h1>
        <!-- Parsed from the online documentation. -->
        <div id="node-1383" class="node node-type-page"><div class="node-inner">
<div class="content">
<h3>The pattern.en module contains a fast, regular expressions-based shallow parser (identifies nouns, adjectives, verbs, etc. in a sentence), a WordNet interface and tools for verb conjugation and noun singularization &amp; pluralization.</h3>
<p>It can be used by itself or with other <a href="pattern.html">pattern</a> modules: <a href="pattern-web.html">web</a> | <a href="pattern-db.html">db</a>&nbsp;| en | <a href="pattern-search.html">search</a> | <a href="pattern-vector.html">vector</a> | <a href="pattern-graph.html">graph</a>.</p>
<p><img src="../g/pattern_schema.gif" alt="" width="620" height="180" /></p>
<hr />
<h2>Documentation</h2>
<ul>
<li><a href="#article">Indefinite article</a></li>
<li><a href="#pluralization">Pluralization + singularization</a></li>
<li><a href="#comparative">Comparative + superlative</a></li>
<li><a href="#conjugation">Verb conjugation</a></li>
<li><a href="#quantify">Quantification</a></li>
<li><a href="#ngram">n-grams</a></li>
<li><a href="#parser">Parser</a>&nbsp;<span class="smallcaps link-maintenance">(tokenizer, tagger, chunker)</span></li>
<li><a href="#tree">Parse trees</a></li>
<li><a href="#sentiment">Sentiment</a></li>
<li><a href="#modality">Mood &amp; modality</a></li>
<li><a href="#wordnet">WordNet</a></li>
<li><a href="#wordlist">Wordlists</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2><a name="article"></a>Indefinite article</h2>
<p>The article is the most common determiner (<span class="postag">DT</span>) in English. It defines whether the noun following it is definite (<em><span style="text-decoration: underline;">the</span> cat</em>) or indefinite (<em><span style="text-decoration: underline;">a</span> cat</em>). The definite article is always <em>the</em>. The indefinite article can be either <em>a</em> or <em>an</em> – depending on how the successive noun is pronounced.</p>
<pre class="brush:python; gutter:false; light:true;">article(word, function=INDEFINITE)   # DEFINITE | INDEFINITE</pre><pre class="brush:python; gutter:false; light:true;">referenced(word, article=INDEFINITE) # Returns article + word.
</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import referenced
&gt;&gt;&gt; print referenced(&#39;university&#39;)
&gt;&gt;&gt; print referenced(&#39;hour&#39;)

a university
an hour</pre></div>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: Granger, M. (2006). <em>Ruby Linguistics Framework</em>, </span><span class="small">http://deveiate.org/projects/Linguistics</span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="pluralization"></a>Pluralization + singularization</h2>
<p>The <span class="inline_code">pluralize()</span> command returns the singular form of a plural noun. It handles 96% of exceptions correctly. The <span class="inline_code">singularize()</span> command returns the plural form of a singular noun. The <span class="inline_code">pos</span> parameter (part-of-speech) can be set to <span class="inline_code">NOUN</span> or <span class="inline_code">ADJECTIVE</span>, but only a small number of possessive adjectives inflect (e.g. <em>my</em> → <em>our</em>). The <span class="inline_code">custom</span> dictionary is for user-defined replacements.</p>
<pre class="brush:python; gutter:false; light:true;">pluralize(word, pos=NOUN, custom={}, classical=True)</pre><pre class="brush:python; gutter:false; light:true;">singularize(word, pos=NOUN, custom={})</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import pluralize, singularize
&gt;&gt;&gt; print pluralize(&#39;child&#39;)
&gt;&gt;&gt; print singularize(&#39;wolves&#39;)

children
wolves
</pre></div>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: <br />Conway, D. (1998). <em>An Algorithmic Approach to English Pluralization</em>.<br />Ferrer, B. (2005). <em>Inflector for Python</em>, http://www.bermi.org/projects/inflector</span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="comparative"></a>Comparative + superlative</h2>
<p>The <span class="inline_code">comparative()</span> and <span class="inline_code">superlative()</span> commands give the comparative or superlative form of an adjective. Words with three or more syllables are simply preceded by <em>more</em> or <em>most</em>.</p>
<pre class="brush:python; gutter:false; light:true;">comparative(adjective)      # big =&gt; bigger</pre><pre class="brush:python; gutter:false; light:true;">superlative(adjective)      # big =&gt; biggest</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import comparative, superlative
&gt;&gt;&gt; print comparative(&#39;bad&#39;)
&gt;&gt;&gt; print superlative(&#39;bad&#39;)

worse
worst
</pre></div>
<p>&nbsp;</p>
<hr />
<h2><a name="conjugation"></a>Verb conjugation</h2>
<p>The <span class="inline_code">pattern.en</span> module has a lexicon of 8,500 common English verbs and their conjugated forms (infinitive, 3rd singular present, present participle, past and past participle – verbs such as <em>be</em> have other forms as well). The following verbs can be negated: <em>be</em>, <em>can</em>, <em>do</em>, <em>will</em>, <em>must</em>, <em>have</em>, <em>may</em>, <em>need</em>, <em>dare</em>, <em>ought</em>.</p>
<pre class="brush:python; gutter:false; light:true;">conjugate(verb, tense=INFINITIVE, negated=False)</pre><pre class="brush:python; gutter:false; light:true;">lemma(verb)                 # Base form, e.g. are =&gt; be.</pre><pre class="brush:python; gutter:false; light:true;">lexeme(verb)                # List of possible forms: be =&gt; is, was, ...</pre><pre class="brush:python; gutter:false; light:true;">tenses(verb)                # List of possible tenses of the given form.
</pre><p>The <span class="inline_code">tense</span> parameter of the <span class="inline_code">conjugate()</span> command can be set to the following values:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Tense</span></td>
<td style="text-align: center;"><span class="smallcaps">Alias</span></td>
<td style="text-align: center;"><span class="smallcaps">Tag</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">INFINITIVE</span></td>
<td style="text-align: center;"><span class="inline_code">"inf"</span></td>
<td style="text-align: center;"><span class="postag">VB</span></td>
<td><em>be</em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_1ST_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"1sg"</span></td>
<td style="text-align: center;"><span class="postag">VBP</span></td>
<td><em>I <span style="text-decoration: underline;">am</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_2ND_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"2sg"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>you <span style="text-decoration: underline;">are</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_3RD_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"3sg"</span></td>
<td style="text-align: center;"><span class="postag">VBZ</span></td>
<td><em>he <span style="text-decoration: underline;">is</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_PLURAL</span></td>
<td style="text-align: center;"><span class="inline_code">"pl"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>we <span style="text-decoration: underline;">are</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_PARTICIPLE</span></td>
<td style="text-align: center;"><span class="inline_code">"part"</span></td>
<td style="text-align: center;"><span class="postag">VBG</span></td>
<td><em>being</em></td>
</tr>
<tr>
<td><span class="inline_code">PAST</span></td>
<td style="text-align: center;"><span class="inline_code">"p"</span></td>
<td style="text-align: center;"><span class="postag">VBD</span></td>
<td><em>were</em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_1ST_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"1sgp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>I <span style="text-decoration: underline;">was</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_2ND_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"2sgp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>you <span style="text-decoration: underline;">were</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_3RD_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"3gp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>he <span style="text-decoration: underline;">was</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_PLURAL</span></td>
<td style="text-align: center;"><span class="inline_code">"ppl"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>we <span style="text-decoration: underline;">were</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_PARTICIPLE</span></td>
<td style="text-align: center;"><span class="inline_code">"ppart"</span></td>
<td style="text-align: center;"><span class="postag">VBN</span></td>
<td><span style="text-decoration: underline;">been</span></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import conjugate, lemma, lexeme, tenses, PAST
&gt;&gt;&gt; print lexeme(&#39;purr&#39;)
&gt;&gt;&gt; print lemma(&#39;purring&#39;)
&gt;&gt;&gt; print conjugate(&#39;purred&#39;, tense=&#39;3sg&#39;)
&gt;&gt;&gt; print PAST in tenses(&quot;purred&quot;) # &#39;p&#39; in tenses() will also work.

[&#39;purr&#39;, &#39;purrs&#39;, &#39;purring&#39;, &#39;purred&#39;]
purr
purrs
True
</pre></div>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: <em>XTAG English morphology</em> (1999), University of Pennsylvania, http://www.cis.upenn.edu/~xtag</span></p>
<p>&nbsp;</p>
<p><span class="smallcaps">Rule-based conjugation</span></p>
<p>All of the verb commands have an optional <span class="inline_code">parse=True</span> parameter that enables a rule-based parser for unknown verbs. This will not work for irregular verbs however, and it is fragile for verbs ending in -e in the past tense or as present participle (overall accuracy 91%).</p>
<p>With <span class="inline_code">parse=False</span>,&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">conjugate()</span>&nbsp;and&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">lemma()</span>&nbsp;yield&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">None</span>.</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import conjugate, VERBS
&gt;&gt;&gt; print &#39;facebooked&#39; in VERBS
&gt;&gt;&gt; print conjugate(&#39;facebooked&#39;, tense=&#39;part&#39;, parse=False)
&gt;&gt;&gt; print conjugate(&#39;facebooked&#39;, tense=&#39;part&#39;, parse=True)

False
None
facebooking
</pre></div>
<p>&nbsp;</p>
<hr />
<h2><a name="quantify"></a>Quantification</h2>
<p>The <span class="inline_code">number()</span> command returns a <span class="inline_code">float</span> or <span class="inline_code">int</span> parsed from the given (numeric) string. If no number can be parsed from the string, it returns <span class="inline_code">0</span>.</p>
<p>The <span class="inline_code">numerals()</span> command returns the given <span class="inline_code">int</span> or <span class="inline_code">float</span> as a string of numerals. By default, the fraction is rounded to two decimals. Because of rounding <span class="inline_code">float(number(x)) == x</span> is not always <span class="inline_code">True</span>.</p>
<p>The <span class="inline_code">quantify()</span> command returns a wordcount approximation. Two similar words are a <em>pair</em>, three to eight <em>several</em>, and so on. Words can be given as a list, a word → count dictionary, or a string + amount.</p>
<p>The <span class="inline_code">reflect()</span> command quantifies Python objects – see the examples bundled with the module.</p>
<pre class="brush:python; gutter:false; light:true;">number(string)              # &quot;seventy-five point two&quot; =&gt; 75.2</pre><pre class="brush:python; gutter:false; light:true;">numerals(n, round=2)        # 2.245 =&gt; &quot;two point twenty-five&quot;</pre><pre class="brush:python; gutter:false; light:true;">quantify([word1, word2, ...], plural={})</pre><pre class="brush:python; gutter:false; light:true;">reflect(object, quantify=True, replace=[])
</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import quantify
&gt;&gt;&gt; print quantify([&#39;goose&#39;, &#39;goose&#39;, &#39;duck&#39;, &#39;chicken&#39;, &#39;chicken&#39;, &#39;chicken&#39;])
&gt;&gt;&gt; print quantify(&#39;carrot&#39;, amount=1000)
&gt;&gt;&gt; print quantify({&#39;carrot&#39;: 100, &#39;parrot&#39;: 20})

several chickens, a pair of geese an⁣d a duck
hundreds of carrots
dozens of carrots an⁣d a score of parrots
</pre></div>
<p>&nbsp;</p>
<hr />
<h2><em><a name="ngram"></a>n</em>-grams</h2>
<p>The <span class="inline_code">ngrams()</span> command returns&nbsp;a list of <em>n</em>-grams (i.e., tuples of <em>n</em> successive words) from the given string.&nbsp;Alternatively, you can supply a <span class="inline_code">Text</span> or <span class="inline_code">Sentence</span> object (see further).&nbsp;<em>n</em>-grams will not run over sentence markers (i.e., .!?).</p>
<pre class="brush:python; gutter:false; light:true;">ngrams(string, n=3)</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; print ngrams(&quot;I am eating a pizza.&quot;, n=3)

[(&#39;I&#39;, &#39;am&#39;, &#39;eating&#39;), (&#39;am&#39;, &#39;eating&#39;, &#39;a&#39;), (&#39;eating&#39;, &#39;a&#39;, &#39;pizza&#39;)] </pre></div>
<p>&nbsp;</p>
<hr />
<h2><a name="parser"></a>Parser</h2>
<p>The core of the <span class="inline_code">pattern.en</span> module is a rule-based shallow parser. To a machine, a text document is nothing more than a string of characters. A shallow parser adds <strong>meaning</strong> by distinguishing between abbreviation periods and sentence breaks, by adding part-of-speech tags to words (is <em>can</em> in this sentence a <span class="postag">NOUN</span> or a <span class="postag">VERB</span>?) and by grouping words that belong together (chunking).</p>
<p>The parser uses a regular expressions-based approach, which is <strong>fast</strong> but not always accurate. The <span class="inline_code">parse()</span> command and the <span class="inline_code">Text</span>, <span class="inline_code">Sentence</span>, <span class="inline_code">Chunk</span> and <span class="inline_code">Word</span> objects (discussed in the next section) are identical to those in <a href="http://www.clips.ua.ac.be/pages/MBSP" target="_blank">MBSP</a> – a shallow parser that uses a statistical machine learning approach. It is more robust, but slower. Output from both parsers can be used in the <span class="inline_code">pattern.search</span> and <span class="inline_code">pattern.vector</span> modules.</p>
<p>The <span class="inline_code">parse()</span> command takes a string of text and returns a tagged Unicode string. <br />Sentences in the output are separated by newline characters.</p>
<pre class="brush:python; gutter:false; light:true;">parse(string, 
   tokenize = True,         # Separate punctuation from words?
       tags = True,         # Parse part-of-speech tags? (NN, JJ, ...)
     chunks = True,         # Parse chunks? (NP, VP, PNP, ...)
  relations = False,        # Find relations? (SBJ, OBJ, ...)
    lemmata = False,        # Find word lemmata? (ate =&gt; eat)
   encoding = &#39;utf-8&#39;,      # Default string encoding?
    default = &#39;NN&#39;,         # Default part-of-speech tag.
      light = False)        # True =&gt; disables contextual rules.
</pre><p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import parse
&gt;&gt;&gt; print parse(&#39;I eat pizza with a fork.&#39;)

I/PRP/B-NP/O eat/VBD/B-VP pizza/NN/B-NP/O with/IN/B-PP/B-PNP a/DT/B-NP/I-PNP
fork/NN/I-NP/I-PNP ././O/O
</pre></div>
<p>Each token (i.e. tagged word) in a sentence has a number of annotations: <span class="inline_code">tags</span><span class="inline_code">=True</span> includes the word part-of-speech tag, <span class="inline_code">chunks=True</span> the chunk tag + <span class="postag">PNP</span> tag (prepositional noun phrase). With <span class="inline_code">tokenize</span> set to <span class="inline_code">False</span>, no tokenization is carried out (the input string is expected to be tokenized). The <span class="inline_code">encoding</span> parameter defines the character encoding of the input string.</p>
<p>The parser is built on a Brill lexicon of tagged words and rules to improve the tags context-wise. With <span class="inline_code">light=False</span>, it uses Brill's contextual rules. With <span class="inline_code">light=True</span> it uses Jason Wiener's simpler ruleset. This ruleset is 5-10x faster but also 25% less accurate.</p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: Brill, E. (1992). <em>A simple rule-based part of speech tagger.</em> ANLC '92 Proceedings.</span></p>
<h3>Parser tags</h3>
<p>Let's examine the word <em>fork</em> and the tags assigned by the parser in the example above:</p>
<table class="border">
<tbody>
<tr>
<td class="smallcaps" style="text-align: center;" align="center">word</td>
<td class="smallcaps" style="text-align: center;" align="center">part-of-speech</td>
<td class="smallcaps" style="text-align: center;" align="center">chunk</td>
<td class="smallcaps" style="text-align: center;" align="center">pnp</td>
</tr>
<tr>
<td align="center">fork</td>
<td align="center"><span class="postag">NN </span></td>
<td align="center"><span class="postag">I-NP</span></td>
<td align="center"><span class="postag">I-PNP</span></td>
</tr>
</tbody>
</table>
<p>The word's part-of-speech tag is <span class="postag">NN</span>, which means that it is a noun. The word occurs in a <span class="postag">NP</span> chunk, a noun phrase (<em>a fork</em>). It is also part of a prepositional noun phrase (<em>with a fork</em>).</p>
<p>Common part-of-speech tags include <span class="postag">NN</span> (noun), <span class="postag">JJ</span> (adjective) and <span class="postag">VB</span> (verb).<br />Common chunk tags include <span class="postag">NP</span> (noun phrase) and <span class="postag">VP</span> (verb phrase).<br />Common relations include <span class="postag">SBJ</span> (subject) and <span class="postag">OBJ</span> (object).</p>
<p>The <a href="MBSP-tags.html" target="_blank">Penn Treebank II tags</a> page gives an overview of all the possible tags generated by the parser.</p>
<h3>Parser shortcuts</h3>
<p>The <span class="inline_code">tag()</span> command returns a list of <span class="inline_code">(word, POStag)</span>-tuples. With <span class="inline_code">light=True</span>, this is the fastest and simplest way to get an idea of a sentence's constituents.</p>
<pre class="brush:python; gutter:false; light:true;">tag(string, tokenize=True, encoding=&#39;utf-8&#39;)</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import tag
&gt;&gt;&gt; for word, tag in tag(&#39;The cat felt happy.&#39;, light=True):
&gt;&gt;&gt;     if tag == &quot;JJ&quot;: # Retrieve all adjectives from the input string.
&gt;&gt;&gt;         print word

happy</pre></div>
<h3>Parser output</h3>
<p>The output of the <span class="inline_code">parse()</span> command is a string of sentences in which each token has been annotated with the requested tags. The <span class="inline_code">pprint()</span> command (extra <em>p</em> is for <em>pretty</em>) gives a good overview of the tags:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import parse, pprint
&gt;&gt;&gt; s = parse(&#39;I ate pizza.&#39;, relations=True, lemmata=True)
&gt;&gt;&gt; pprint(s) 

    WORD   TAG    CHUNK   ROLE   ID     PNP    LEMMA
       I   PRP    NP      SBJ    1      -      i   
     ate   VBP    VP      -      1      -      eat         
   pizza   NN     NP      OBJ    1      -      pizza         
       .   .      -       -      -      -      .        </pre></div>
<p>The output string is a <span class="inline_code">TaggedString</span> object that behaves as a Python string, but with a <span class="inline_code">TaggedString.split()</span> method that yields (without parameters) a list of sentences, where each sentence is a list of tokens, in which each token is a list of the word + its tags.</p>
<p>If you want to analyze the output (i.e. examine the relations between words and groups of words), the most convenient way is to construct a <a href="#tree" target="_self">parse tree</a> from the output.</p>
<p>&nbsp;</p>
<hr />
<h2><a name="tree"></a>Parse trees</h2>
<p>A parse tree stores a tagged string as a network of linked Python objects that can be traversed to analyze the constituents in the text. The output of the <a href="#parser" target="_self">parser</a> can be passed to the <span class="inline_code">split()</span> command, which produces a <span class="inline_code">Text</span> object. Essentially, a <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects. Each <span class="inline_code">Sentence</span> consists of <span class="inline_code">Word</span> objects. <span class="inline_code">Word</span> objects are also grouped in <span class="inline_code">Chunk</span> objects, which are related to other <span class="inline_code">Chunk</span> objects in various ways.</p>
<pre class="brush:python; gutter:false; light:true;">split(taggedstring, token=[WORD, POS, CHUNK, PNP])</pre><p>We'll run the sentence "<em>The cat sat on the mat.</em>" through the parse tree:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import parse, split
&gt;&gt;&gt; s = parse(&#39;The cat sat on the mat.&#39;, relations=True, lemmata=True)
&gt;&gt;&gt; s = split(s)
&gt;&gt;&gt; print repr(s)

[Sentence(
 &#39;The/DT/B-NP/O/NP-SBJ-1/the 
  cat/NN/I-NP/O/NP-SBJ-1/cat 
  sat/VBD/B-VP/O/VP-1/sit 
  on/IN/B-PP/B-PNP/O/on 
  the/DT/B-NP/I-PNP/O/the 
  mat/NN/I-NP/I-PNP/O/mat 
  ././O/O/O/O/.&#39;)]</pre><pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; print s[0].chunks

[Chunk(&#39;The cat/NP-SBJ-1&#39;), 
 Chunk(&#39;sat/VP-1&#39;), 
 Chunk(&#39;on/PP&#39;), 
 Chunk(&#39;the mat/NP&#39;)]</pre></div>
<h3>Text</h3>
<p>A <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects (i.e. you can do: <span class="inline_code">for sentence in text</span>).</p>
<pre class="brush:python; gutter:false; light:true;">text = Text(taggedstring)</pre><pre class="brush:python; gutter:false; light:true;">text = Text.from_xml(xml)  # Reads an XML-string generated with Text.xml.
</pre><pre class="brush:python; gutter:false; light:true;">text.string                # &#39;The cat sat on the mat .&#39;
text.sentences             # [Sentence(&#39;The cat sat on the mat .&#39;)]
text.copy()
text.xml</pre><h3>Sentence</h3>
<p>A <span class="inline_code">Sentence</span> is a list of <span class="inline_code">Word</span> objects, with attributes + methods that organize words in <span class="inline_code">Chunk</span> objects.</p>
<pre class="brush:python; gutter:false; light:true;">sentence = Sentence(taggedstring)</pre><pre class="brush:python; gutter:false; light:true;">sentence = Sentence.from_xml(xml) 
</pre><pre class="brush:python; gutter:false; light:true;">sentence.parent            # Sentence parent (for a Slice), or None.
sentence.id                # Unique for each sentence.
sentence.start             # 0
sentence.stop              # Sentence length.
</pre><pre class="brush:python; gutter:false; light:true;">sentence.string            # Tokenized string, without tags.
sentence.words             # List of Word objects.
sentence.chunks            # List of Chunk objects.
sentence.subjects          # List of NP-SBJ chunks.
sentence.objects           # List of NP-OBJ chunks.
sentence.verbs             # List of VP chunks.
sentence.relations         # {&#39;SBJ&#39;: {1: Chunk(&#39;the cat/NP-SBJ-1&#39;)},
                           #   &#39;VP&#39;: {1: Chunk(&#39;sat/VP-1&#39;)},
                           #  &#39;OBJ&#39;: {}}
sentence.pnp               # List of PNPChunks: [Chunk(&#39;on the mat/PNP&#39;)]
</pre><pre class="brush:python; gutter:false; light:true;">sentence.constituents(pnp=False)</pre><pre class="brush:python; gutter:false; light:true;">sentence.slice(start, stop)
sentence.copy()
sentence.xml
</pre><ul>
<li><span class="inline_code">Sentence.constituents()</span> returns an in-order list of <span class="inline_code">Word</span> and <span class="inline_code">Chunk</span> objects.<br />With <span class="inline_code">pnp=True</span>, also groups into&nbsp;<span class="inline_code">PNPChunk</span> objects whenever possible.</li>
<li><span class="inline_code">Sentence.slice() </span>returns a <span class="inline_code">Slice</span> (subclass of <span class="inline_code">Sentence</span>) starting with the word at index <span class="inline_code">start</span> and containing all the words up to (before) index <span class="inline_code">stop</span>.</li>
</ul>
<h3>Sentence words</h3>
<p>A <span class="inline_code">Sentence</span> is made up of <span class="inline_code">Word</span> objects, which are also grouped in <span class="inline_code">Chunk</span> objects:</p>
<pre class="brush:python; gutter:false; light:true;">word = Word(sentence, string, lemma=None, type=None, index=0)</pre><pre class="brush:python; gutter:false; light:true;">word.sentence              # Sentence parent.
word.index                 # Sentence index of word.
word.string                # String (Unicode).
word.lemma                 # String lemma, e.g. &#39;sat&#39; =&gt; &#39;sit&#39;,
word.type                  # Part-of-speech tag (NN, JJ, VBD, ...)
word.chunk                 # Chunk parent, or None.
word.pnp                   # PNPChunk parent, or None.</pre><h3>Sentence chunks</h3>
<p>A <span class="inline_code">Chunk</span> is a list of <span class="inline_code">Word</span> objects that belong together. <br />Chunks can be part of a <span class="inline_code">PNPChunk</span>, which starts with a <span class="postag">PP</span> chunk followed by <span class="postag">NP</span> chunks.</p>
<pre class="brush:python; gutter:false; light:true;">chunk = Chunk(sentence, words=[], type=None, role=None, relation=None)</pre><pre class="brush:python; gutter:false; light:true;">chunk.sentence             # Sentence parent.
chunk.start                # Sentence index of first word.
chunk.stop                 # Sentence index of last word + 1.
chunk.string               # String of words (Unicode).
chunk.words                # List of Word objects.
chunk.head                 # Primary Word in the chunk.
chunk.type                 # Chunk tag (NP, VP, PP, ...)
chunk.role                 # Role tag (SBJ, OBJ, ...)
chunk.relation             # Relation id, e.g. NP-SBJ-1 =&gt; 1.
chunk.relations            # List of (id, role)-tuples.
chunk.related              # List of Chunks with same relation id.
chunk.subject              # NP-SBJ chunk with same id.
chunk.object               # NP-OBJ chunk with same id.
chunk.verb                 # VP chunk with same id.
chunk.modifiers            # []
chunk.conjunctions         # []
chunk.pnp                  # PNPChunk parent, or None.
</pre><pre class="brush:python; gutter:false; light:true;">chunk.previous(type=None)
chunk.next(type=None)
chunk.nearest(type=&#39;VP&#39;)</pre><ul>
<li><span class="inline_code">Chunk.head</span> yields the last (i.e. primary) <span class="inline_code">Word</span> in the chunk: <em>the big cat</em> → <em>cat</em>.</li>
<li><span class="inline_code">Chunk.relations</span><span class="inline_code">&nbsp;</span> contains <em>all</em> relations the chunk is involved in. <br />Some chunks have multiple relations, for example functioning as both <span class="postag">SBJ</span> and <span class="postag">OBJ</span>, or being the <span class="postag">OBJ</span> of multiple <span class="postag">VP</span> chunks.</li>
<li>For <span class="postag">VP</span> chunks, <span class="inline_code">Chunk.modifiers</span> is a list of nearby adjectives and adverbs with no relations. <br />For example in <em>the cat really wants out</em>: <em>really</em> and <em>out</em> are <span class="postag">ADVP</span> with no relations. <br />The parse tree will assume that they have something to do with the <span class="postag">VP</span> <em>wants</em>. <br />What does the cat want? → <em>out</em>. <br />How badly does the cat want out? → <em>really</em>.</li>
<li><span class="inline_code">Chunk.conjunctions</span> is a list of chunks linked by <em>and</em> &amp; <em>or</em> to this chunk. <br />For example in <em>going up and down</em>: the <em>up</em> chunk has conjunctions: <span class="inline_code">[(Chunk('down'), AND)] </span></li>
</ul>
<h3>Prepositional noun phrases</h3>
<p><span class="inline_code">PNPChunk</span> is a subclass of <span class="inline_code">Chunk</span>. It has the same attributes and methods. <br />It groups <span class="postag">PP</span> + <span class="postag">NP</span> chunks in a prepositional noun phrase (<span class="postag">PNP</span>).</p>
<pre class="brush:python; gutter:false; light:true;">pnp = PNPChunk(sentence, words=[], type=None, role=None, relation=None)</pre><pre class="brush:python; gutter:false; light:true;">pnp.string                 # String of words (Unicode).
pnp.chunks                 # List of Chunk objects.
pnp.preposition            # First PP-chunk in the PNP.
</pre><p>Words and chunks that are part of a <span class="postag">PNP</span> will have their <span class="inline_code">Word.pnp</span> and <span class="inline_code">Chunk.pnp</span> attribute set.<br />All the prepositional noun phrases in a sentence can be retrieved with <span class="inline_code">Sentence.pnp</span>.</p>
<p>&nbsp;</p>
<hr />
<h2><a name="sentiment"></a>Sentiment</h2>
<p>Text can be broadly categorized into two types: facts and opinions. Opinions carry people's sentiments, appraisals and feelings toward the world. The module bundles a lexicon of adjectives that occur frequently in product reviews, tagged with scores for sentiment polarity (positive/negative) and subjectivity.&nbsp;</p>
<p>The <span class="inline_code">sentiment()</span> command returns a (<span class="inline_code">polarity</span>, <span class="inline_code">subjectivity</span>)-tuple for the given sentence (based on the adjectives in it),&nbsp;with polarity between <span class="inline_code">-1.0</span> and <span class="inline_code">1.0</span> and subjectivity between <span class="inline_code">0.0</span> and <span class="inline_code">1.0</span>.&nbsp;The sentence can be a string, <span class="inline_code">Text</span>, <span class="inline_code">Sentence</span>, <span class="inline_code">Chunk</span>,&nbsp;<span class="inline_code">Word</span> or a&nbsp;<span class="inline_code">Synset</span> (see further).</p>
<pre class="brush:python; gutter:false; light:true;">sentiment(sentence)</pre><pre class="brush:python; gutter:false; light:true;">polarity(sentence)</pre><pre class="brush:python; gutter:false; light:true;">subjectivity(sentence)</pre><pre class="brush:python; gutter:false; light:true;">positive(s, threshold=0.1)</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import sentiment
&gt;&gt;&gt; print sentiment(
&gt;&gt;&gt;     &quot;The movie attempts to be surreal by incorporating various time paradoxes,&quot;
&gt;&gt;&gt;     &quot;but it&#39;s presented in such a ridiculous way it&#39;s seriously boring.&quot;) 

(-0.34, 1.0) </pre></div>
<p>In the example above,&nbsp;<span class="inline_code">-0.34</span> is a compromise between <em>surreal</em>, <em>various</em>, <em>ridiculous</em> and <em>seriously boring</em>.</p>
<p>The <span class="inline_code">polarity()</span> command returns&nbsp;the sentence polarity (positive/negative sentiment).&nbsp;</p>
<p>The <span class="inline_code">subjectivity()</span> command returns the sentence subjectivity (objective/subjective).</p>
<p>The <span class="inline_code">positive()</span> command returns&nbsp;<span class="inline_code">True</span> if the given sentence's polarity is above the threshold. The threshold can be lowered or raised, but overall&nbsp;<span class="inline_code">+0.1</span> gives the best results for product reviews. Accuracy is 72% (P 0.72, R 0.71) for movie reviews.</p>
<p>&nbsp;</p>
<hr />
<h2><a name="modality"></a>Mood &amp; modality</h2>
<p>Linguistic modality deals with necessity, permissibility and probability.&nbsp;</p>
<pre class="brush:python; gutter:false; light:true;">mood(sentence) # INDICATIVE | IMPERATIVE | CONDITIONAL | SUBJUNCTIVE</pre><pre class="brush:python; gutter:false; light:true;">modality(sentence, type=EPISTEMIC)</pre><pre class="brush:python; gutter:false; light:true;">negated(sentence)</pre><p>The <span class="inline_code">mood()</span> command tries to identify a parsed&nbsp;<span class="inline_code">Sentence</span> as indicative, imperative, conditional or subjunctive:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Mood</span></td>
<td><span class="smallcaps">Form</span></td>
<td><span class="smallcaps">Use</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">INDICATIVE</span></td>
<td>none of the below&nbsp;</td>
<td>fact, belief</td>
<td><em>It is raining.</em></td>
</tr>
<tr>
<td><span class="inline_code">IMPERATIVE</span></td>
<td>infinitive without <em>to</em></td>
<td>warning, instruction</td>
<td><em>Do your homework!</em></td>
</tr>
<tr>
<td><span class="inline_code">CONDITIONAL</span></td>
<td>would|could|should, will|can + <em>if</em></td>
<td>possible or imaginary</td>
<td><em>I could show you.</em></td>
</tr>
<tr>
<td><span class="inline_code">SUBJUNCTIVE</span></td>
<td>wish|were, <em>it is</em> + infinitive</td>
<td>wish, judgement, opinion</td>
<td><em>I wish I knew.</em></td>
</tr>
</tbody>
</table>
<p>The <span class="inline_code">mood()</span> command has an optional&nbsp;<span style="font-family: Courier, monospace; font-size: 12px;">predictive=True</span>&nbsp;parameter that determines how conditional sentences are handled.&nbsp;When&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">False</span>, sentences with will/shall&nbsp;must have&nbsp;an explicit if/when/once clause in order to be identified as conditional. For example:&nbsp;while&nbsp;<em>"You will help me"</em>&nbsp;is imperative,&nbsp;<em>"I will help you"</em>&nbsp;is predictive conditional and "<em>I will help you when I get back"</em>&nbsp;is speculative conditional.&nbsp;Sentences with can/may always need an explicit if-clause.</p>
<p>The <span class="inline_code">modality()</span> command returns a value between <span class="inline_code">-1.0</span> and +<span class="inline_code">1.0</span>, expressing the degree of possibility:&nbsp;<em>"I wish it would stop raining"</em> scores <span class="inline_code">-0.35</span> whereas <em>"It will surely stop raining"</em> scores <span class="inline_code">+0.75</span>. Roughly,&nbsp;<span class="inline_code">&gt;0.5</span>&nbsp;can be seen as certain. Accuracy (F1-score) when predicting certain vs. uncertain is around 67% for Wikipedia texts.</p>
<p>The <span class="inline_code">negated()</span> command returns <span class="inline_code">True</span> if the <span class="inline_code">Sentence</span> contains <em>never</em>, <em>not</em> or <em>n't</em> (as in <em>would<span style="text-decoration: underline;">n't</span></em>).</p>
<p>&nbsp;</p>
<hr />
<h2><a name="wordnet"></a>WordNet</h2>
<p>The <span class="inline_code">pattern.en</span> module comes bundled with WordNet 3.0 and Oliver Steele's PyWordNet module. <a href="http://wordnet.princeton.edu/" target="_blank">WordNet</a> is a lexical database for the English language, that groups words into <span class="inline_code">Synset</span> objects (= sets of synonyms). Each synset provides a short definition and various semantic relations to other synsets:</p>
<pre class="brush:python; gutter:false; light:true;">synset = synsets(word, pos=NOUN)[i]</pre><pre class="brush:python; gutter:false; light:true;">synset.pos                  # Part-of-speech: NOUN | VERB | ADJECTIVE | ADVERB.
synset.synonyms             # List of word forms (i.e. synonyms).
synset.gloss                # Definition string.
synset.lexname              # Category string, or None.
synset.ic                   # Information Content value.
synset.weight               # Tuple of (polarity, subjectivity), using SentiWordNet.</pre><pre class="brush:python; gutter:false; light:true;">synset.antonym              # A Synset (semantical opposite).
synset.hypernym             # A Synset (semantical parent).</pre><pre class="brush:python; gutter:false; light:true;">synset.hypernyms(recursive=False, depth=None)
synset.hyponyms(recursive=False, depth=None)
synset.meronyms()           # List of synsets (members/parts).
synset.holonyms()           # List of synsets (of which this is a member).
synset.similar()            # List of synsets (similar adjectives/verbs) </pre><ul>
<li><span class="inline_code">Synset.hypernyms()</span> returns a list of <em>&nbsp;</em>parent synsets (i.e. more general).</li>
<li><span class="inline_code">Synset.hyponyms()</span> returns a list child synsets (i.e. more specific).<br />With <span class="inline_code">recursive=True</span>, returns all parents of all parents / all children of all children.<br />Optionally returns parents / children recursively up to the given <span class="inline_code">depth</span>.</li>
</ul>
<p>For example:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import wordnet
&gt;&gt;&gt; s = wordnet.synsets(&#39;bird&#39;)[0]
&gt;&gt;&gt; print &#39;Definition:&#39;, s.gloss
&gt;&gt;&gt; print &#39;  Synonyms:&#39;, s.synonyms
&gt;&gt;&gt; print &#39; Hypernyms:&#39;, s.hypernyms()
&gt;&gt;&gt; print &#39;  Hyponyms:&#39;, s.hyponyms()
&gt;&gt;&gt; print &#39;  Holonyms:&#39;, s.holonyms()
&gt;&gt;&gt; print &#39;  Meronyms:&#39;, s.meronyms()

Definition: u&#39;warm-blooded egg-laying vertebrates characterized 
              by feathers and forelimbs modified as wings&#39;
  Synonyms: [&#39;bird&#39;]
 Hypernyms: [Synset(&#39;vertebrate&#39;)]
  Hyponyms: [Synset(&#39;dickeybird&#39;), Synset(&#39;cock&#39;), Synset(&#39;hen&#39;), ...]
  Holonyms: [Synset(&#39;Aves&#39;), Synset(&#39;flock&#39;)]
  Meronyms: [Synset(&#39;beak&#39;), Synset(&#39;furcula&#39;), Synset(&#39;feather&#39;), ...]</pre></div>
<div class="example"><span class="small"><span style="text-decoration: underline;">Reference</span>: Fellbaum, C. (1998). </span><em class="small">WordNet: An Electronic Lexical Database</em><span class="small">. Cambridge, MIT Press.</span></div>
<h3>Synset similarity</h3>
<p>The <span class="inline_code">ancestor()</span> command returns the common ancestor (or <em>least common subsumer</em>) of two synsets.<br />The <span class="inline_code">similarity()</span> command returns the semantic similarity of two synsets, as a number.</p>
<pre class="brush:python; gutter:false; light:true;">ancestor(synset1, synset2)</pre><pre class="brush:python; gutter:false; light:true;">similarity(synset1, synset2) # Lower value = higher similarity.
</pre><div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; a = wordnet.synsets(&#39;cat&#39;)[0]
&gt;&gt;&gt; b = wordnet.synsets(&#39;dog&#39;)[0]
&gt;&gt;&gt; print wordnet.ancestor(a, b)

Synset(&#39;carnivore&#39;)
</pre></div>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; c = wordnet.synsets(&#39;teapot&#39;)[0]
&gt;&gt;&gt; print wordnet.similarity(a, b)
&gt;&gt;&gt; print wordnet.similarity(a, c)

3.29
4152.56</pre></div>
<p>The similarity weight is based on Lin-similarity and Information Content (IC). IC values for each synset are derived from the word's occurence in a given corpus (e.g. Brown). The idea is that less frequent words convey more information. Lower values indicate higher similarity:</p>
<p><span class="inline_code">lin = 2.0 * ancestor(synset1, synset2).ic / (synset1.ic + synset2.ic)</span></p>
<h3>Synset sentiment</h3>
<p><a href="http://sentiwordnet.isti.cnr.it/" target="_blank">SentiWordNet</a> is a third-party lexical resource for opinion mining, with polarity and subjectivity scores for all WordNet synsets. SentiWordNet is free for non-commercial research purposes. To enable SentiWordNet, request a download from the authors and place the file <span class="inline_code">SentiWordNet*.txt</span> in&nbsp;<span class="inline_code">pattern/en/wordnet/</span>.&nbsp;You can then use&nbsp;<span class="inline_code">wordnet.sentiwordnet</span>&nbsp;and <span class="inline_code">Synset.weight()</span> in your script:</p>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en import wordnet
&gt;&gt;&gt; from pattern.en import ADJECTIVE
&gt;&gt;&gt; print wordnet.sentiwordnet[&#39;lamp&#39;]
&gt;&gt;&gt; print wordnet.synsets(&#39;happy&#39;, ADJECTIVE)[0].weight
&gt;&gt;&gt; print wordnet.synsets(&#39;sad&#39;, ADJECTIVE)[0].weight

(0.0, 0.0)
(0.375, 0.875)
(-0.625, 0.875)
</pre></div>
<p>&nbsp;</p>
<hr />
<h2><a name="wordlist"></a>Wordlists</h2>
<p>The <span class="inline_code">patten.en</span> module includes a number of general-purpose word lists:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">List</span></td>
<td><span class="smallcaps">Description</span></td>
<td style="text-align: center;"><span class="smallcaps">Size</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">ACADEMIC</span></td>
<td>English academic words</td>
<td style="text-align: center;">500</td>
<td><em>criterion</em>, <em>proportionally</em>, <em>research</em></td>
</tr>
<tr>
<td><span class="inline_code">BASIC</span></td>
<td>English basic words</td>
<td style="text-align: center;">1,000</td>
<td><em>chicken</em>, <em>pain</em>, <em>road</em></td>
</tr>
<tr>
<td><span class="inline_code">PROFANITY</span></td>
<td>English swear words</td>
<td style="text-align: center;">350</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><span class="inline_code">TIME</span></td>
<td>English time &amp; date words</td>
<td style="text-align: center;">100</td>
<td><em>Christmas</em>, <em>past</em>, <em>saturday</em></td>
</tr>
</tbody>
</table>
<div class="example">
<pre class="brush:python; gutter:false; light:true;">&gt;&gt;&gt; from pattern.en.wordlist import ACADEMIC
&gt;&gt;&gt; words = open(&quot;paper.txt&quot;).read().split(&quot; &quot;)
&gt;&gt;&gt; words = [w for w in words if w not in ACADEMIC] </pre></div>
<p>&nbsp;</p>
<hr />
<h2>See also</h2>
<ul>
<li><a href="http://www.clips.ua.ac.be/pages/MBSP" target="_blank">MBSP</a> (GPL): r<span>obust parser using a memory-based learning approach, in Python.</span></li>
<li><span><a href="http://www.nltk.org/" target="_blank">NLTK</a> (Apache): f</span><span>ull natural language processing toolkit for Python.</span></li>
</ul>
</div>
</div></div>
        </div>
    </div>
    </div>
    </div>
    </div>
    </div>
    <script>
        SyntaxHighlighter.all();
    </script>
</body>
</html>