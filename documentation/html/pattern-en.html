<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>pattern-en</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link type="text/css" rel="stylesheet" href="../clips.css" />
    <style>
        /* Small fixes because we omit the online layout.css. */
        h3 { line-height: 1.3em; }
        #page { margin-left: auto; margin-right: auto; }
        #header, #header-inner { height: 175px; }
        #header { border-bottom: 1px solid #C6D4DD;  }
        table { border-collapse: collapse; }
    </style>
</head>
<body class="node-type-page one-sidebar sidebar-right section-pages">
    <div id="page">
    <div id="page-inner">
    <div id="header"><div id="header-inner"></div></div>
    <div id="content">
    <div id="content-inner">
    <div class="node node-type-page"
        <div class="node-inner">
        <div class="breadcrumb">View online at: <a href="http://www.clips.ua.ac.be/pages/pattern-en" class="noexternal" target="_blank">http://www.clips.ua.ac.be/pages/pattern-en</a></div>
        <h1>pattern.en</h1>
        <!-- Parsed from the online documentation. -->
        <div id="node-1383" class="node node-type-page"><div class="node-inner">
<div class="content">
<h3>The pattern.en module contains a fast, regular expressions-based shallow parser (identifies nouns, adjectives, verbs, etc. in a sentence), a WordNet interface and tools for verb conjugation and noun singularization &amp; pluralization.</h3>
<p>It can be used by itself or with other <a href="pattern.html">pattern</a> modules: <a href="pattern-web.html">web</a> | <a href="pattern-db.html">db</a>&nbsp;| en | <a href="pattern-search.html">search</a> | <a href="pattern-vector.html">vector</a> | <a href="pattern-graph.html">graph</a>.</p>
<p><img src="../g/pattern_schema.gif" alt="" width="620" height="180" /></p>
<hr />
<h2>Documentation</h2>
<ul>
<li><a href="#article">Indefinite article</a></li>
<li><a href="#pluralization">Pluralization + singularization</a></li>
<li><a href="#comparative">Comparative + superlative</a></li>
<li><a href="#conjugation">Verb conjugation</a></li>
<li><a href="#quantify">Quantification</a></li>
<li><a href="#ngram">n-grams</a></li>
<li><a href="#parser">Parser</a>&nbsp;<span class="smallcaps link-maintenance">(tokenizer, tagger, chunker)</span></li>
<li><a href="#tree">Parse trees</a></li>
<li><a href="#sentiment">Sentiment</a></li>
<li><a href="#modality">Mood &amp; modality</a></li>
<li><a href="#wordnet">WordNet</a></li>
<li><a href="#wordlist">Wordlists</a></li>
</ul>
<p>&nbsp;</p>
<h2>
<hr /><a name="article"></a>Indefinite article</h2>
<p>The article is the most common determiner (<span class="postag">DT</span>) in English. It defines whether the noun following it is definite (<em><span style="text-decoration: underline;">the</span> cat</em>) or indefinite (<em><span style="text-decoration: underline;">a</span> cat</em>). The definite article is always <em>the</em>. The indefinite article can be either <em>a</em> or <em>an</em> – depending on how the successive noun is pronounced.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">article<span style="">&#40;</span>word, function=INDEFINITE<span style="">&#41;</span> &nbsp; <span style="color: grey;"># DEFINITE | INDEFINITE</span></code></span><span class="geshifilter"><code class="python geshifilter-python">referenced<span style="">&#40;</span>word, article=INDEFINITE<span style="">&#41;</span> <span style="color: grey;"># Returns article + word.</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> referenced<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> referenced<span style="">&#40;</span><span style="color: #657a8a;">'university'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> referenced<span style="">&#40;</span><span style="color: #657a8a;">'hour'</span><span style="">&#41;</span><br />
<br />
a university<br />
an hour</code></span></span></p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: Granger, M. (2006). <em>Ruby Linguistics Framework</em>, </span><span class="small">http://deveiate.org/projects/Linguistics</span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="pluralization"></a>Pluralization + singularization</h2>
<p>The <span class="inline_code">pluralize()</span> command returns the singular form of a plural noun. It handles 96% of exceptions correctly. The <span class="inline_code">singularize()</span> command returns the plural form of a singular noun. The <span class="inline_code">pos</span> parameter (part-of-speech) can be set to <span class="inline_code">NOUN</span> or <span class="inline_code">ADJECTIVE</span>, but only a small number of possessive adjectives inflect (e.g. <em>my</em> → <em>our</em>). The <span class="inline_code">custom</span> dictionary is for user-defined replacements.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">pluralize<span style="">&#40;</span>word, pos=NOUN, custom=<span style="">&#123;</span><span style="">&#125;</span>, classical=<span style="color: #4a587c;">True</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">singularize<span style="">&#40;</span>word, pos=NOUN, custom=<span style="">&#123;</span><span style="">&#125;</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> pluralize, singularize<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> pluralize<span style="">&#40;</span><span style="color: #657a8a;">'child'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> singularize<span style="">&#40;</span><span style="color: #657a8a;">'wolves'</span><span style="">&#41;</span><br />
<br />
children<br />
wolves</code></span></span></p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: <br />Conway, D. (1998). <em>An Algorithmic Approach to English Pluralization</em>.<br />Ferrer, B. (2005). <em>Inflector for Python</em>, http://www.bermi.org/projects/inflector</span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="comparative"></a>Comparative + superlative</h2>
<p>The <span class="inline_code">comparative()</span> and <span class="inline_code">superlative()</span> commands give the comparative or superlative form of an adjective. Words with three or more syllables are simply preceded by <em>more</em> or <em>most</em>.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">comparative<span style="">&#40;</span>adjective<span style="">&#41;</span> &nbsp; &nbsp; &nbsp;<span style="color: grey;"># big =&gt; bigger</span></code></span><span class="geshifilter"><code class="python geshifilter-python">superlative<span style="">&#40;</span>adjective<span style="">&#41;</span> &nbsp; &nbsp; &nbsp;<span style="color: grey;"># big =&gt; biggest</span></code></span><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> comparative, superlative<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> comparative<span style="">&#40;</span><span style="color: #657a8a;">'bad'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> superlative<span style="">&#40;</span><span style="color: #657a8a;">'bad'</span><span style="">&#41;</span><br />
<br />
worse<br />
worst</code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="conjugation"></a>Verb conjugation</h2>
<p>The <span class="inline_code">pattern.en</span> module has a lexicon of 8,500 common English verbs and their conjugated forms (infinitive, 3rd singular present, present participle, past and past participle – verbs such as <em>be</em> have other forms as well). The following verbs can be negated: <em>be</em>, <em>can</em>, <em>do</em>, <em>will</em>, <em>must</em>, <em>have</em>, <em>may</em>, <em>need</em>, <em>dare</em>, <em>ought</em>.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">conjugate<span style="">&#40;</span>verb, tense=INFINITIVE, negated=<span style="color: #4a587c;">False</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">lemma<span style="">&#40;</span>verb<span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Base form, e.g. are =&gt; be.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">lexeme<span style="">&#40;</span>verb<span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of possible forms: be =&gt; is, was, ...</span></code></span><span class="geshifilter"><code class="python geshifilter-python">tenses<span style="">&#40;</span>verb<span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of possible tenses of the given form.</span></code></span></p>
<p>The <span class="inline_code">tense</span> parameter of the <span class="inline_code">conjugate()</span> command can be set to the following values:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Tense</span></td>
<td style="text-align: center;"><span class="smallcaps">Alias</span></td>
<td style="text-align: center;"><span class="smallcaps">Tag</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">INFINITIVE</span></td>
<td style="text-align: center;"><span class="inline_code">"inf"</span></td>
<td style="text-align: center;"><span class="postag">VB</span></td>
<td><em>be</em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_1ST_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"1sg"</span></td>
<td style="text-align: center;"><span class="postag">VBP</span></td>
<td><em>I <span style="text-decoration: underline;">am</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_2ND_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"2sg"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>you <span style="text-decoration: underline;">are</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_3RD_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"3sg"</span></td>
<td style="text-align: center;"><span class="postag">VBZ</span></td>
<td><em>he <span style="text-decoration: underline;">is</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_PLURAL</span></td>
<td style="text-align: center;"><span class="inline_code">"pl"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>we <span style="text-decoration: underline;">are</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PRESENT_PARTICIPLE</span></td>
<td style="text-align: center;"><span class="inline_code">"part"</span></td>
<td style="text-align: center;"><span class="postag">VBG</span></td>
<td><em>being</em></td>
</tr>
<tr>
<td><span class="inline_code">PAST</span></td>
<td style="text-align: center;"><span class="inline_code">"p"</span></td>
<td style="text-align: center;"><span class="postag">VBD</span></td>
<td><em>were</em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_1ST_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"1sgp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>I <span style="text-decoration: underline;">was</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_2ND_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"2sgp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>you <span style="text-decoration: underline;">were</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_3RD_PERSON_SINGULAR</span></td>
<td style="text-align: center;"><span class="inline_code">"3gp"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>he <span style="text-decoration: underline;">was</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_PLURAL</span></td>
<td style="text-align: center;"><span class="inline_code">"ppl"</span></td>
<td style="text-align: center;">&nbsp;·</td>
<td><em>we <span style="text-decoration: underline;">were</span></em></td>
</tr>
<tr>
<td><span class="inline_code">PAST_PARTICIPLE</span></td>
<td style="text-align: center;"><span class="inline_code">"ppart"</span></td>
<td style="text-align: center;"><span class="postag">VBN</span></td>
<td><span style="text-decoration: underline;">been</span></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> conjugate, lemma, lexeme, tenses, PAST<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> lexeme<span style="">&#40;</span><span style="color: #657a8a;">'purr'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> lemma<span style="">&#40;</span><span style="color: #657a8a;">'purring'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> conjugate<span style="">&#40;</span><span style="color: #657a8a;">'purred'</span>, tense=<span style="color: #657a8a;">'3sg'</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> PAST <span style="color: #28334f; font-weight: bold;">in</span> tenses<span style="">&#40;</span><span style="color: #657a8a;">&quot;purred&quot;</span><span style="">&#41;</span> <span style="color: grey;"># 'p' in tenses() will also work.</span><br />
<br />
<span style="">&#91;</span><span style="color: #657a8a;">'purr'</span>, <span style="color: #657a8a;">'purrs'</span>, <span style="color: #657a8a;">'purring'</span>, <span style="color: #657a8a;">'purred'</span><span style="">&#93;</span><br />
purr<br />
purrs<br />
<span style="color: #4a587c;">True</span></code></span></span></p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: <em>XTAG English morphology</em> (1999), University of Pennsylvania, http://www.cis.upenn.edu/~xtag</span></p>
<p>&nbsp;</p>
<p><span class="smallcaps">Rule-based conjugation</span></p>
<p>All of the verb commands have an optional <span class="inline_code">parse=True</span> parameter that enables a rule-based parser for unknown verbs. This will not work for irregular verbs however, and it is fragile for verbs ending in -e in the past tense or as present participle (overall accuracy 91%).</p>
<p>With <span class="inline_code">parse=False</span>,&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">conjugate()</span>&nbsp;and&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">lemma()</span>&nbsp;yield&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">None</span>.</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> conjugate, VERBS<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">'facebooked'</span> <span style="color: #28334f; font-weight: bold;">in</span> VERBS<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> conjugate<span style="">&#40;</span><span style="color: #657a8a;">'facebooked'</span>, tense=<span style="color: #657a8a;">'part'</span>, parse=<span style="color: #4a587c;">False</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> conjugate<span style="">&#40;</span><span style="color: #657a8a;">'facebooked'</span>, tense=<span style="color: #657a8a;">'part'</span>, parse=<span style="color: #4a587c;">True</span><span style="">&#41;</span><br />
<br />
<span style="color: #4a587c;">False</span><br />
<span style="color: #4a587c;">None</span><br />
facebooking</code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="quantify"></a>Quantification</h2>
<p>The <span class="inline_code">number()</span> command returns a <span class="inline_code">float</span> or <span class="inline_code">int</span> parsed from the given (numeric) string. If no number can be parsed from the string, it returns <span class="inline_code">0</span>.</p>
<p>The <span class="inline_code">numerals()</span> command returns the given <span class="inline_code">int</span> or <span class="inline_code">float</span> as a string of numerals. By default, the fractional part is rounded to two decimals. Because of rounding <span class="inline_code">float(number(x)) == x</span> is not always <span class="inline_code">True</span>.</p>
<p>The <span class="inline_code">quantify()</span> command returns a wordcount approximation. Two similar words are a <em>pair</em>, three to eight <em>several</em>, and so on. Words can be given as a list, a word → count dictionary, or a string + amount.</p>
<p>The <span class="inline_code">reflect()</span> command quantifies Python objects – see the examples bundled with the module.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">number<span style="">&#40;</span><span style="">string</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># &quot;seventy-five point two&quot; =&gt; 75.2</span></code></span><span class="geshifilter"><code class="python geshifilter-python">numerals<span style="">&#40;</span>n, <span style="color: #4a587c;">round</span>=<span style="color: #666;">2</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># 2.245 =&gt; &quot;two point twenty-five&quot;</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">quantify<span style="">&#40;</span><span style="">&#91;</span>word1, word2, ...<span style="">&#93;</span>, plural=<span style="">&#123;</span><span style="">&#125;</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">reflect<span style="">&#40;</span><span style="color: #4a587c;">object</span>, quantify=<span style="color: #4a587c;">True</span>, replace=<span style="">&#91;</span><span style="">&#93;</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> quantify<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> quantify<span style="">&#40;</span><span style="">&#91;</span><span style="color: #657a8a;">'goose'</span>, <span style="color: #657a8a;">'goose'</span>, <span style="color: #657a8a;">'duck'</span>, <span style="color: #657a8a;">'chicken'</span>, <span style="color: #657a8a;">'chicken'</span>, <span style="color: #657a8a;">'chicken'</span><span style="">&#93;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> quantify<span style="">&#40;</span><span style="color: #657a8a;">'carrot'</span>, amount=<span style="color: #666;">1000</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> quantify<span style="">&#40;</span><span style="">&#123;</span><span style="color: #657a8a;">'carrot'</span>: <span style="color: #666;">100</span>, <span style="color: #657a8a;">'parrot'</span>: <span style="color: #666;">20</span><span style="">&#125;</span><span style="">&#41;</span><br />
<br />
several chickens, a pair of geese a​nd a duck<br />
hundreds of carrots<br />
dozens of carrots a​nd a score of parrots</code></span></span></p>
<p>&nbsp;</p>
<h2>
<hr /><em><a name="ngram"></a>n</em>-grams</h2>
<p>The <span class="inline_code">ngrams()</span> command returns&nbsp;a list of <em>n</em>-grams (i.e., tuples of <em>n</em> successive words) from the given string.&nbsp;Alternatively, you can supply a <span class="inline_code">Text</span> or <span class="inline_code">Sentence</span> object (see further).&nbsp;<em>n</em>-grams will not run over sentence markers (i.e., .!?).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">ngrams<span style="">&#40;</span><span style="">string</span>, n=<span style="color: #666;">3</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> ngrams<span style="">&#40;</span><span style="color: #657a8a;">&quot;I am eating a pizza.&quot;</span>, n=<span style="color: #666;">3</span><span style="">&#41;</span><br />
<br />
<span style="">&#91;</span><span style="">&#40;</span><span style="color: #657a8a;">'I'</span>, <span style="color: #657a8a;">'am'</span>, <span style="color: #657a8a;">'eating'</span><span style="">&#41;</span>, <span style="">&#40;</span><span style="color: #657a8a;">'am'</span>, <span style="color: #657a8a;">'eating'</span>, <span style="color: #657a8a;">'a'</span><span style="">&#41;</span>, <span style="">&#40;</span><span style="color: #657a8a;">'eating'</span>, <span style="color: #657a8a;">'a'</span>, <span style="color: #657a8a;">'pizza'</span><span style="">&#41;</span><span style="">&#93;</span> </code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="parser"></a>Parser</h2>
<p>The core of the <span class="inline_code">pattern.en</span> module is a rule-based shallow parser. To a machine, a text document is nothing more than a string of characters. A shallow parser adds <strong>meaning</strong> by distinguishing between abbreviation periods and sentence breaks, by adding part-of-speech tags to words (is <em>can</em> in this sentence a <span class="postag">NOUN</span> or a <span class="postag">VERB</span>?) and by grouping words that belong together (chunking).</p>
<p>The parser uses a regular expressions-based approach, which is <strong>fast</strong> but not always accurate. The <span class="inline_code">parse()</span> command and the <span class="inline_code">Text</span>, <span class="inline_code">Sentence</span>, <span class="inline_code">Chunk</span> and <span class="inline_code">Word</span> objects (discussed in the next section) are identical to those in <a href="http://www.clips.ua.ac.be/pages/MBSP" target="_blank">MBSP</a> – a shallow parser that uses a statistical machine learning approach. It is more robust, but slower. Output from both parsers can be used in the <span class="inline_code">pattern.search</span> and <span class="inline_code">pattern.vector</span> modules.</p>
<p>The <span class="inline_code">parse()</span> command takes a string of text and returns a tagged Unicode string. <br />Sentences in the output are separated by newline characters.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">parse<span style="">&#40;</span><span style="">string</span>, <br />
&nbsp; &nbsp;<span style="">tokenize</span> = <span style="color: #4a587c;">True</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Separate punctuation from words?</span><br />
&nbsp; &nbsp; &nbsp; &nbsp;tags = <span style="color: #4a587c;">True</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Parse part-of-speech tags? (NN, JJ, ...)</span><br />
&nbsp; &nbsp; &nbsp;chunks = <span style="color: #4a587c;">True</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Parse chunks? (NP, VP, PNP, ...)</span><br />
&nbsp; relations = <span style="color: #4a587c;">False</span>, &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Find relations? (SBJ, OBJ, ...)</span><br />
&nbsp; &nbsp; lemmata = <span style="color: #4a587c;">False</span>, &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Find word lemmata? (ate =&gt; eat)</span><br />
&nbsp; &nbsp;encoding = <span style="color: #657a8a;">'utf-8'</span>, &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Default string encoding?</span><br />
&nbsp; &nbsp; default = <span style="color: #657a8a;">'NN'</span>, &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Default part-of-speech tag.</span><br />
&nbsp; &nbsp; &nbsp; light = <span style="color: #4a587c;">False</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># True =&gt; disables contextual rules.</span></code></span></p>
<p>For example:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> parse<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> parse<span style="">&#40;</span><span style="color: #657a8a;">'I eat pizza with a fork.'</span><span style="">&#41;</span><br />
<br />
I/PRP/B-NP/O eat/VBD/B-VP pizza/NN/B-NP/O with/IN/B-PP/B-PNP a/DT/B-NP/I-PNP fork/NN/I-NP/I-PNP ././O/O</code></span></span></p>
<p>Each token (i.e. tagged word) in a sentence has a number of annotations: <span class="inline_code">tags</span><span class="inline_code">=True</span> includes the word part-of-speech tag, <span class="inline_code">chunks=True</span> the chunk tag + <span class="postag">PNP</span> tag (prepositional noun phrase). With <span class="inline_code">tokenize</span> set to <span class="inline_code">False</span>, no tokenization is carried out (the input string is expected to be tokenized). The <span class="inline_code">encoding</span> parameter defines the character encoding of the input string.</p>
<p>The parser is built on a Brill lexicon of tagged words and rules to improve the tags context-wise. With <span class="inline_code">light=False</span>, it uses Brill's contextual rules. With <span class="inline_code">light=True</span> it uses Jason Wiener's simpler ruleset. This ruleset is 5-10x faster but also 25% less accurate.</p>
<p><span class="small"><span style="text-decoration: underline;">Reference</span>: Brill, E. (1992). <em>A simple rule-based part of speech tagger.</em> ANLC '92 Proceedings.</span></p>
<h3>Parser tags</h3>
<p>Let's examine the word <em>fork</em> and the tags assigned by the parser in the example above:</p>
<table class="border">
<tbody>
<tr>
<td class="smallcaps" style="text-align: center;" align="center">word</td>
<td class="smallcaps" style="text-align: center;" align="center">part-of-speech</td>
<td class="smallcaps" style="text-align: center;" align="center">chunk</td>
<td class="smallcaps" style="text-align: center;" align="center">pnp</td>
</tr>
<tr>
<td align="center">fork</td>
<td align="center"><span class="postag">NN </span></td>
<td align="center"><span class="postag">I-NP</span></td>
<td align="center"><span class="postag">I-PNP</span></td>
</tr>
</tbody>
</table>
<p>The word's part-of-speech tag is <span class="postag">NN</span>, which means that it is a noun. The word occurs in a <span class="postag">NP</span> chunk, a noun phrase (<em>a fork</em>). It is also part of a prepositional noun phrase (<em>with a fork</em>).</p>
<p>Common part-of-speech tags include <span class="postag">NN</span> (noun), <span class="postag">JJ</span> (adjective) and <span class="postag">VB</span> (verb).<br />Common chunk tags include <span class="postag">NP</span> (noun phrase) and <span class="postag">VP</span> (verb phrase).<br />Common relations include <span class="postag">SBJ</span> (subject) and <span class="postag">OBJ</span> (object).</p>
<p>The <a href="MBSP-tags.html" target="_blank">Penn Treebank II tags</a> page gives an overview of all the possible tags generated by the parser.</p>
<h3>Parser shortcuts</h3>
<p>The <span class="inline_code">tag()</span> command returns a list of <span class="inline_code">(word, POStag)</span>-tuples. With <span class="inline_code">light=True</span>, this is the fastest and simplest way to get an idea of a sentence's constituents.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">tag<span style="">&#40;</span><span style="">string</span>, <span style="">tokenize</span>=<span style="color: #4a587c;">True</span>, encoding=<span style="color: #657a8a;">'utf-8'</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> tag<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">for</span> word, tag <span style="color: #28334f; font-weight: bold;">in</span> tag<span style="">&#40;</span><span style="color: #657a8a;">'The cat felt happy.'</span>, light=<span style="color: #4a587c;">True</span><span style="">&#41;</span>:<br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; <span style="color: #28334f; font-weight: bold;">if</span> tag == <span style="color: #657a8a;">&quot;JJ&quot;</span>: <span style="color: grey;"># Retrieve all adjectives from the input string.</span><br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #28334f; font-weight: bold;">print</span> word<br />
<br />
happy</code></span></span></p>
<h3>Parser output</h3>
<p>The output of the <span class="inline_code">parse()</span> command is a string of sentences in which each token has been annotated with the requested tags. The <span class="inline_code">pprint()</span> command (extra <em>p</em> is for <em>pretty</em>) gives a good overview of the tags:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> parse, <span style="">pprint</span><br />
<span style="">&gt;&gt;&gt;</span> s = parse<span style="">&#40;</span><span style="color: #657a8a;">'I ate pizza.'</span>, relations=<span style="color: #4a587c;">True</span>, lemmata=<span style="color: #4a587c;">True</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="">pprint</span><span style="">&#40;</span>s<span style="">&#41;</span> <br />
<br />
&nbsp; &nbsp; WORD &nbsp; TAG &nbsp; &nbsp;CHUNK &nbsp; ROLE &nbsp; ID &nbsp; &nbsp; PNP &nbsp; &nbsp;LEMMA<br />
&nbsp; &nbsp; &nbsp; &nbsp;I &nbsp; PRP &nbsp; &nbsp;NP &nbsp; &nbsp; &nbsp;SBJ &nbsp; &nbsp;<span style="color: #666;">1</span> &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;i &nbsp; <br />
&nbsp; &nbsp; &nbsp;ate &nbsp; VBP &nbsp; &nbsp;VP &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;<span style="color: #666;">1</span> &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;eat &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp;pizza &nbsp; NN &nbsp; &nbsp; NP &nbsp; &nbsp; &nbsp;OBJ &nbsp; &nbsp;<span style="color: #666;">1</span> &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;pizza &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; . &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;- &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp;</code></span></span></p>
<p>The output string is a <span class="inline_code">TaggedString</span> object that behaves as a Python string, but with a <span class="inline_code">TaggedString.split()</span> method that yields (without parameters) a list of sentences, where each sentence is a list of tokens,  in which each token is a list of the word + its tags.</p>
<p>If  you want to analyze the output (i.e. examine the relations between  words and groups of words), the most convenient way is to construct a <a href="#tree" target="_self">parse tree</a> from the output.</p>
<p>&nbsp;</p>
<hr />
<h2><a name="tree"></a>Parse trees</h2>
<p>A parse tree stores a tagged string as a network of linked Python  objects that can be traversed to analyze the constituents in the text.  The output of the <a href="#parser" target="_self">parser</a> can be passed to the <span class="inline_code">split()</span> command, which produces a <span class="inline_code">Text</span> object. Essentially, a <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects. Each <span class="inline_code">Sentence</span> consists of <span class="inline_code">Word</span> objects. <span class="inline_code">Word</span> objects are also grouped in <span class="inline_code">Chunk</span> objects, which are related to other <span class="inline_code">Chunk</span> objects in various ways.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">split<span style="">&#40;</span>taggedstring, <span style="">token</span>=<span style="">&#91;</span>WORD, POS, CHUNK, PNP<span style="">&#93;</span><span style="">&#41;</span></code></span></p>
<p>We'll run the sentence "<em>The cat sat on the mat.</em>" through the parse tree:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> parse, split<br />
<span style="">&gt;&gt;&gt;</span> s = parse<span style="">&#40;</span><span style="color: #657a8a;">'The cat sat on the mat.'</span>, relations=<span style="color: #4a587c;">True</span>, lemmata=<span style="color: #4a587c;">True</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> s = split<span style="">&#40;</span>s<span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #4a587c;">repr</span><span style="">&#40;</span>s<span style="">&#41;</span><br />
<br />
<span style="">&#91;</span>Sentence<span style="">&#40;</span><br />
&nbsp;<span style="color: #657a8a;">'The/DT/B-NP/O/NP-SBJ-1/the <br />
&nbsp; cat/NN/I-NP/O/NP-SBJ-1/cat <br />
&nbsp; sat/VBD/B-VP/O/VP-1/sit <br />
&nbsp; on/IN/B-PP/B-PNP/O/on <br />
&nbsp; the/DT/B-NP/I-PNP/O/the <br />
&nbsp; mat/NN/I-NP/I-PNP/O/mat <br />
&nbsp; ././O/O/O/O/.'</span><span style="">&#41;</span><span style="">&#93;</span></code></span><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> s<span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span>.<span style="">chunks</span><br />
<br />
<span style="">&#91;</span>Chunk<span style="">&#40;</span><span style="color: #657a8a;">'The cat/NP-SBJ-1'</span><span style="">&#41;</span>, <br />
&nbsp;Chunk<span style="">&#40;</span><span style="color: #657a8a;">'sat/VP-1'</span><span style="">&#41;</span>, <br />
&nbsp;Chunk<span style="">&#40;</span><span style="color: #657a8a;">'on/PP'</span><span style="">&#41;</span>, <br />
&nbsp;Chunk<span style="">&#40;</span><span style="color: #657a8a;">'the mat/NP'</span><span style="">&#41;</span><span style="">&#93;</span></code></span></span></p>
<h3>Text</h3>
<p>A <span class="inline_code">Text</span> is a list of <span class="inline_code">Sentence</span> objects (i.e. you can do: <span class="inline_code">for sentence in text</span>).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">text = Text<span style="">&#40;</span>taggedstring<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">text = Text.<span style="">from_xml</span><span style="">&#40;</span><span style="">xml</span><span style="">&#41;</span> &nbsp;<span style="color: grey;"># Reads an XML-string generated with Text.xml.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">text.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># 'The cat sat on the mat .'</span><br />
text.<span style="">sentences</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># [Sentence('The cat sat on the mat .')]</span><br />
text.<span style="">copy</span><span style="">&#40;</span><span style="">&#41;</span><br />
text.<span style="">xml</span></code></span></p>
<h3>Sentence</h3>
<p>A <span class="inline_code">Sentence</span> is a list of <span class="inline_code">Word</span> objects, with attributes + methods that organize words in <span class="inline_code">Chunk</span> objects.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentence = Sentence<span style="">&#40;</span>taggedstring<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">sentence = Sentence.<span style="">from_xml</span><span style="">&#40;</span><span style="">xml</span><span style="">&#41;</span> </code></span><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="">parent</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence parent (for a Slice), or None.</span><br />
sentence.<span style="color: #4a587c;">id</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Unique for each sentence.</span><br />
sentence.<span style="">start</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># 0</span><br />
sentence.<span style="">stop</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence length.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Tokenized string, without tags.</span><br />
sentence.<span style="">words</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of Word objects.</span><br />
sentence.<span style="">chunks</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of Chunk objects.</span><br />
sentence.<span style="">subjects</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of NP-SBJ chunks.</span><br />
sentence.<span style="">objects</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of NP-OBJ chunks.</span><br />
sentence.<span style="">verbs</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of VP chunks.</span><br />
sentence.<span style="">relations</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># {'SBJ': {1: Chunk('the cat/NP-SBJ-1')},</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># &nbsp; 'VP': {1: Chunk('sat/VP-1')},</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># &nbsp;'OBJ': {}}</span><br />
sentence.<span style="">pnp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of PNPChunks: [Chunk('on the mat/PNP')]</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="">constituents</span><span style="">&#40;</span>pnp=<span style="color: #4a587c;">False</span><span style="">&#41;</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentence.<span style="color: #4a587c;">slice</span><span style="">&#40;</span>start, stop<span style="">&#41;</span><br />
sentence.<span style="">copy</span><span style="">&#40;</span><span style="">&#41;</span><br />
sentence.<span style="">xml</span></code></span></p>
<ul>
<li><span class="inline_code">Sentence.constituents()</span> returns an in-order list of <span class="inline_code">Word</span> and <span class="inline_code">Chunk</span> objects.<br />With <span class="inline_code">pnp=True</span>, also groups into&nbsp;<span class="inline_code">PNPChunk</span> objects whenever possible.</li>
<li><span class="inline_code">Sentence.slice() </span>returns a <span class="inline_code">Slice</span> (subclass of <span class="inline_code">Sentence</span>) starting with the word at index <span class="inline_code">start</span> and containing all the words up to (before) index <span class="inline_code">stop</span>.</li>
</ul>
<h3>Sentence words</h3>
<p>A <span class="inline_code">Sentence</span> is made up of <span class="inline_code">Word</span> objects, which are also grouped in <span class="inline_code">Chunk</span> objects:</p>
<p><span class="geshifilter"><code class="python geshifilter-python">word = Word<span style="">&#40;</span>sentence, <span style="">string</span>, lemma=<span style="color: #4a587c;">None</span>, type=<span style="color: #4a587c;">None</span>, index=<span style="color: #666;">0</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">word.<span style="">sentence</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence parent.</span><br />
word.<span style="">index</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Sentence index of word.</span><br />
word.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># String (Unicode).</span><br />
word.<span style="">lemma</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># String lemma, e.g. 'sat' =&gt; 'sit',</span><br />
word.<span style="">type</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Part-of-speech tag (NN, JJ, VBD, ...)</span><br />
word.<span style="">chunk</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Chunk parent, or None.</span><br />
word.<span style="">pnp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># PNPChunk parent, or None.</span></code></span></p>
<h3>Sentence chunks</h3>
<p>A <span class="inline_code">Chunk</span> is a list of <span class="inline_code">Word</span> objects that belong together. <br />Chunks can be part of a <span class="inline_code">PNPChunk</span>, which starts with a <span class="postag">PP</span> chunk followed by <span class="postag">NP</span> chunks.</p>
<p><span class="geshifilter"><code class="python geshifilter-python"><span style="">chunk</span> = Chunk<span style="">&#40;</span>sentence, words=<span style="">&#91;</span><span style="">&#93;</span>, type=<span style="color: #4a587c;">None</span>, role=<span style="color: #4a587c;">None</span>, relation=<span style="color: #4a587c;">None</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python"><span style="">chunk</span>.<span style="">sentence</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Sentence parent.</span><br />
<span style="">chunk</span>.<span style="">start</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Sentence index of first word.</span><br />
<span style="">chunk</span>.<span style="">stop</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Sentence index of last word + 1.</span><br />
<span style="">chunk</span>.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># String of words (Unicode).</span><br />
<span style="">chunk</span>.<span style="">words</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of Word objects.</span><br />
<span style="">chunk</span>.<span style="">head</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Primary Word in the chunk.</span><br />
<span style="">chunk</span>.<span style="">type</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Chunk tag (NP, VP, PP, ...)</span><br />
<span style="">chunk</span>.<span style="">role</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Role tag (SBJ, OBJ, ...)</span><br />
<span style="">chunk</span>.<span style="">relation</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Relation id, e.g. NP-SBJ-1 =&gt; 1.</span><br />
<span style="">chunk</span>.<span style="">relations</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of (id, role)-tuples.</span><br />
<span style="">chunk</span>.<span style="">related</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of Chunks with same relation id.</span><br />
<span style="">chunk</span>.<span style="">subject</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># NP-SBJ chunk with same id.</span><br />
<span style="">chunk</span>.<span style="color: #4a587c;">object</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># NP-OBJ chunk with same id.</span><br />
<span style="">chunk</span>.<span style="">verb</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># VP chunk with same id.</span><br />
<span style="">chunk</span>.<span style="">modifiers</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># []</span><br />
<span style="">chunk</span>.<span style="">conjunctions</span> &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># []</span><br />
<span style="">chunk</span>.<span style="">pnp</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># PNPChunk parent, or None.</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python"><span style="">chunk</span>.<span style="">previous</span><span style="">&#40;</span>type=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
<span style="">chunk</span>.<span style="">next</span><span style="">&#40;</span>type=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
<span style="">chunk</span>.<span style="">nearest</span><span style="">&#40;</span>type=<span style="color: #657a8a;">'VP'</span><span style="">&#41;</span></code></span></p>
<ul>
<li><span class="inline_code">Chunk.head</span> yields the last (i.e. primary) <span class="inline_code">Word</span> in the chunk: <em>the big cat</em> → <em>cat</em>.</li>
<li><span class="inline_code">Chunk.relations</span><span class="inline_code">&nbsp;</span> contains <em>all</em> relations the chunk is involved in. <br />Some chunks have multiple relations, for example functioning as both <span class="postag">SBJ</span> and <span class="postag">OBJ</span>, or being the <span class="postag">OBJ</span> of multiple <span class="postag">VP</span> chunks. </li>
<li>For <span class="postag">VP</span> chunks, <span class="inline_code">Chunk.modifiers</span> is a list of nearby adjectives and adverbs with no relations. <br />For example in <em>the cat really wants out</em>: <em>really</em> and <em>out</em> are <span class="postag">ADVP</span> with no relations. <br />The parse tree will assume that they have something to do with the <span class="postag">VP</span> <em>wants</em>. <br />What does the cat want? → <em>out</em>. <br />How badly does the cat want out? → <em>really</em>.</li>
<li><span class="inline_code">Chunk.conjunctions</span> is a list of chunks linked by <em>and</em> &amp; <em>or</em> to this chunk. <br />For example in <em>going up and down</em>: the <em>up</em> chunk has conjunctions: <span class="inline_code">[(Chunk('down'), AND)] </span></li>
</ul>
<h3>Prepositional noun phrases</h3>
<p><span class="inline_code">PNPChunk</span> is a subclass of <span class="inline_code">Chunk</span>. It has the same attributes and methods. <br />It groups <span class="postag">PP</span> + <span class="postag">NP</span> chunks in a prepositional noun phrase (<span class="postag">PNP</span>).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">pnp = PNPChunk<span style="">&#40;</span>sentence, words=<span style="">&#91;</span><span style="">&#93;</span>, type=<span style="color: #4a587c;">None</span>, role=<span style="color: #4a587c;">None</span>, relation=<span style="color: #4a587c;">None</span><span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">pnp.<span style="">string</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># String of words (Unicode).</span><br />
pnp.<span style="">chunks</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of Chunk objects.</span><br />
pnp.<span style="">preposition</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># First PP-chunk in the PNP.</span></code></span></p>
<p>Words and chunks that are part of a <span class="postag">PNP</span> will have their <span class="inline_code">Word.pnp</span> and <span class="inline_code">Chunk.pnp</span> attribute set.<br />All the prepositional noun phrases in a sentence can be retrieved with <span class="inline_code">Sentence.pnp</span>.</p>
<p>&nbsp;</p>
<h2>
<hr /><a name="sentiment"></a>Sentiment</h2>
<p>Text can be broadly categorized into two types: facts and opinions. Opinions carry people's sentiments, appraisals and feelings toward the world. The module bundles a lexicon of adjectives that occur frequently in product reviews, tagged with scores for sentiment polarity (positive/negative) and subjectivity.&nbsp;</p>
<p>The <span class="inline_code">sentiment()</span> command returns a (<span class="inline_code">polarity</span>, <span class="inline_code">subjectivity</span>)-tuple for the given sentence (based on the adjectives in it),&nbsp;with polarity between <span class="inline_code">-1.0</span> and <span class="inline_code">1.0</span> and subjectivity between <span class="inline_code">0.0</span> and <span class="inline_code">1.0</span>.&nbsp;The sentence can be a string, <span class="inline_code">Text</span>, <span class="inline_code">Sentence</span>, <span class="inline_code">Chunk</span>,&nbsp;<span class="inline_code">Word</span> or a&nbsp;<span class="inline_code">Synset</span> (see further).</p>
<p><span class="geshifilter"><code class="python geshifilter-python">sentiment<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">polarity<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">subjectivity<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">positive<span style="">&#40;</span>s, threshold=<span style="color: #666;">0.1</span><span style="">&#41;</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> sentiment<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> sentiment<span style="">&#40;</span><br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; <span style="color: #657a8a;">&quot;The movie attempts to be surreal by incorporating various time paradoxes,&quot;</span><br />
<span style="">&gt;&gt;&gt;</span> &nbsp; &nbsp; <span style="color: #657a8a;">&quot;but it's presented in such a ridiculous way it's seriously boring.&quot;</span><span style="">&#41;</span> <br />
<br />
<span style="">&#40;</span>-<span style="color: #666;">0.34</span>, <span style="color: #666;">1.0</span><span style="">&#41;</span> </code></span></span></p>
<p>In the example above,&nbsp;<span class="inline_code">-0.34</span> is a compromise between <em>surreal</em>, <em>various</em>, <em>ridiculous</em> and <em>seriously boring</em>.</p>
<p>The <span class="inline_code">polarity()</span> command returns&nbsp;the sentence polarity (positive/negative sentiment).&nbsp;</p>
<p>The <span class="inline_code">subjectivity()</span> command returns the sentence subjectivity (objective/subjective).</p>
<p>The <span class="inline_code">positive()</span> command returns&nbsp;<span class="inline_code">True</span> if the given sentence's polarity is above the threshold. The threshold can be lowered or raised, but overall&nbsp;<span class="inline_code">+0.1</span> gives the best results for product reviews. Accuracy is 72% (P 0.72, R 0.71) for movie reviews.</p>
<p>&nbsp;</p>
<h2>
<hr /></h2>
<h2><a name="modality"></a>Mood &amp; modality</h2>
<p>Linguistic modality deals with necessity, permissibility and probability.&nbsp;</p>
<p><span class="geshifilter"><code class="python geshifilter-python">mood<span style="">&#40;</span>sentence<span style="">&#41;</span> <span style="color: grey;"># INDICATIVE | IMPERATIVE | CONDITIONAL | SUBJUNCTIVE</span></code></span><span class="geshifilter"><code class="python geshifilter-python">modality<span style="">&#40;</span>sentence, type=EPISTEMIC<span style="">&#41;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">negated<span style="">&#40;</span>sentence<span style="">&#41;</span></code></span></p>
<p>The <span class="inline_code">mood()</span> command tries to identify a parsed&nbsp;<span class="inline_code">Sentence</span> as indicative, imperative, conditional or subjunctive:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">Mood</span></td>
<td><span class="smallcaps">Form</span></td>
<td><span class="smallcaps">Use</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">INDICATIVE</span></td>
<td>none of the below&nbsp;</td>
<td>fact, belief</td>
<td><em>It is raining.</em></td>
</tr>
<tr>
<td><span class="inline_code">IMPERATIVE</span></td>
<td>infinitive without <em>to</em></td>
<td>warning, instruction</td>
<td><em>Do your homework!</em></td>
</tr>
<tr>
<td><span class="inline_code">CONDITIONAL</span></td>
<td>would|could|should, will|can + <em>if</em></td>
<td>possible or imaginary</td>
<td><em>I could show you.</em></td>
</tr>
<tr>
<td><span class="inline_code">SUBJUNCTIVE</span></td>
<td>wish|were, <em>it is</em> + infinitive</td>
<td>wish, judgement, opinion</td>
<td><em>I wish I knew.</em></td>
</tr>
</tbody>
</table>
<p>The <span class="inline_code">mood()</span> command has an optional&nbsp;<span style="font-family: Courier, monospace; font-size: 12px;">predictive=True</span>&nbsp;parameter that determines how conditional sentences are handled.&nbsp;When&nbsp;<span class="inline_code" style="font-family: Courier, monospace; font-size: 12px;">False</span>, sentences with will/shall&nbsp;must have&nbsp;an explicit if/when/once clause in order to be identified as conditional. For example:&nbsp;while&nbsp;<em>"You will help me"</em>&nbsp;is imperative,&nbsp;<em>"I will help you"</em>&nbsp;is predictive conditional and "<em>I will help you when I get back"</em>&nbsp;is speculative conditional.&nbsp;Sentences with can/may always need an explicit if-clause.</p>
<p>The <span class="inline_code">modality()</span> command returns a value between <span class="inline_code">-1.0</span> and +<span class="inline_code">1.0</span>, expressing the degree of possibility:&nbsp;<em>"I wish it would stop raining"</em> scores <span class="inline_code">-0.35</span> whereas <em>"It will surely stop raining"</em> scores <span class="inline_code">+0.75</span>. Roughly,&nbsp;<span class="inline_code">&gt;0.5</span>&nbsp;can be seen as certain. Accuracy (F1-score) when predicting certain vs. uncertain is around 67% for Wikipedia texts.</p>
<p>The <span class="inline_code">negated()</span> command returns <span class="inline_code">True</span> if the <span class="inline_code">Sentence</span> contains <em>never</em>, <em>not</em> or <em>n't</em> (as in <em>would<span style="text-decoration: underline;">n't</span></em>).</p>
<p>&nbsp;</p>
<hr />
<h2><a name="wordnet"></a>WordNet</h2>
<p>The <span class="inline_code">pattern.en</span> module comes bundled with WordNet 3.0 and Oliver Steele's PyWordNet module. <a href="http://wordnet.princeton.edu/" target="_blank">WordNet</a> is a lexical database for the English language, that groups words into <span class="inline_code">Synset</span> objects (= sets of synonyms). Each synset provides a short definition and various semantic relations to other synsets:</p>
<p><span class="geshifilter"><code class="python geshifilter-python">synset = synsets<span style="">&#40;</span>word, pos=NOUN<span style="">&#41;</span><span style="">&#91;</span>i<span style="">&#93;</span></code></span><span class="geshifilter"><code class="python geshifilter-python">synset.<span style="">pos</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Part-of-speech: NOUN | VERB | ADJECTIVE | ADVERB.</span><br />
synset.<span style="">synonyms</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of word forms (i.e. synonyms).</span><br />
synset.<span style="">gloss</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Definition string.</span><br />
synset.<span style="">lexname</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># Category string, or None.</span><br />
synset.<span style="">ic</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Information Content value.</span><br />
synset.<span style="">weight</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># Tuple of (polarity, subjectivity), using SentiWordNet.</span></code></span><span class="geshifilter"><code class="python geshifilter-python">synset.<span style="">antonym</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># A Synset (semantical opposite).</span><br />
synset.<span style="">hypernym</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># A Synset (semantical parent).</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">synset.<span style="">hypernyms</span><span style="">&#40;</span>recursive=<span style="color: #4a587c;">False</span>, depth=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
synset.<span style="">hyponyms</span><span style="">&#40;</span>recursive=<span style="color: #4a587c;">False</span>, depth=<span style="color: #4a587c;">None</span><span style="">&#41;</span><br />
synset.<span style="">meronyms</span><span style="">&#40;</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of synsets (members/parts).</span><br />
synset.<span style="">holonyms</span><span style="">&#40;</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: grey;"># List of synsets (of which this is a member).</span><br />
synset.<span style="">similar</span><span style="">&#40;</span><span style="">&#41;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: grey;"># List of synsets (similar adjectives/verbs) </span></code></span></p>
<ul>
<li><span class="inline_code">Synset.hypernyms()</span> returns a list of <em>&nbsp;</em>parent synsets (i.e. more general).</li>
<li><span class="inline_code">Synset.hyponyms()</span> returns a list child synsets (i.e. more specific).<br />With <span class="inline_code">recursive=True</span>, returns all parents of all parents / all children of all children.<br />Optionally returns parents / children recursively up to the given <span class="inline_code">depth</span>.</li>
</ul>
<p>For example:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> wordnet<br />
<span style="">&gt;&gt;&gt;</span> s = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'bird'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">'Definition:'</span>, s.<span style="">gloss</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Synonyms:'</span>, s.<span style="">synonyms</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' Hypernyms:'</span>, s.<span style="">hypernyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Hyponyms:'</span>, s.<span style="">hyponyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Holonyms:'</span>, s.<span style="">holonyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> <span style="color: #657a8a;">' &nbsp;Meronyms:'</span>, s.<span style="">meronyms</span><span style="">&#40;</span><span style="">&#41;</span><br />
<br />
Definition: u<span style="color: #657a8a;">'warm-blooded egg-laying vertebrates characterized <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by feathers and forelimbs modified as wings'</span><br />
&nbsp; Synonyms: <span style="">&#91;</span><span style="color: #657a8a;">'bird'</span><span style="">&#93;</span><br />
&nbsp;Hypernyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'vertebrate'</span><span style="">&#41;</span><span style="">&#93;</span><br />
&nbsp; Hyponyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'dickeybird'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'cock'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'hen'</span><span style="">&#41;</span>, ...<span style="">&#93;</span><br />
&nbsp; Holonyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'Aves'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'flock'</span><span style="">&#41;</span><span style="">&#93;</span><br />
&nbsp; Meronyms: <span style="">&#91;</span>Synset<span style="">&#40;</span><span style="color: #657a8a;">'beak'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'furcula'</span><span style="">&#41;</span>, Synset<span style="">&#40;</span><span style="color: #657a8a;">'feather'</span><span style="">&#41;</span>, ...<span style="">&#93;</span></code></span></span></p>
<p><span class="example"><span class="small"><span style="text-decoration: underline;">Reference</span>: Fellbaum, C. (1998). <em>WordNet: An Electronic Lexical Database</em>. Cambridge, MIT Press.</span><br /></span></p>
<h3>Synset similarity</h3>
<p>The <span class="inline_code">ancestor()</span> command returns the common ancestor (or <em>least common subsumer</em>) of two synsets.<br />The <span class="inline_code">similarity()</span> command returns the semantic similarity of two synsets, as a number.</p>
<p><span class="geshifilter"><code class="python geshifilter-python">ancestor<span style="">&#40;</span>synset1, synset2<span style="">&#41;</span></code></span></p>
<p><span class="geshifilter"><code class="python geshifilter-python">similarity<span style="">&#40;</span>synset1, synset2<span style="">&#41;</span> <span style="color: grey;"># Lower value = higher similarity.</span></code></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> a = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'cat'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> b = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'dog'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">ancestor</span><span style="">&#40;</span>a, b<span style="">&#41;</span><br />
<br />
Synset<span style="">&#40;</span><span style="color: #657a8a;">'carnivore'</span><span style="">&#41;</span></code></span></span></p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> c = wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'teapot'</span><span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">similarity</span><span style="">&#40;</span>a, b<span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">similarity</span><span style="">&#40;</span>a, c<span style="">&#41;</span><br />
<br />
<span style="color: #666;">3.29</span><br />
<span style="color: #666;">4152.56</span></code></span></span></p>
<p>The similarity weight is based on Lin-similarity and Information Content (IC). IC values for each synset are derived from the word's occurence in a given corpus (e.g. Brown). The idea is that less frequent words convey more information. Lower values indicate higher similarity:</p>
<p><span class="inline_code">lin = 2.0 * ancestor(synset1, synset2).ic / (synset1.ic + synset2.ic)</span></p>
<h3>Synset sentiment</h3>
<p><a href="http://sentiwordnet.isti.cnr.it/" target="_blank">SentiWordNet</a> is a third-party lexical resource for opinion mining, with polarity and subjectivity scores for all WordNet synsets. SentiWordNet is free for non-commercial research purposes. To enable SentiWordNet, request a download from the authors and place the file <span class="inline_code">SentiWordNet*.txt</span> in&nbsp;<span class="inline_code">pattern/en/wordnet/</span>.&nbsp;You can then use&nbsp;<span class="inline_code">wordnet.sentiwordnet</span>&nbsp;and <span class="inline_code">Synset.weight()</span> in your script:</p>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> wordnet<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span> <span style="color: #28334f; font-weight: bold;">import</span> ADJECTIVE<br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">sentiwordnet</span><span style="">&#91;</span><span style="color: #657a8a;">'lamp'</span><span style="">&#93;</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'happy'</span>, ADJECTIVE<span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span>.<span style="">weight</span><br />
<span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">print</span> wordnet.<span style="">synsets</span><span style="">&#40;</span><span style="color: #657a8a;">'sad'</span>, ADJECTIVE<span style="">&#41;</span><span style="">&#91;</span><span style="color: #666;">0</span><span style="">&#93;</span>.<span style="">weight</span><br />
<br />
<span style="">&#40;</span><span style="color: #666;">0.0</span>, <span style="color: #666;">0.0</span><span style="">&#41;</span><br />
<span style="">&#40;</span><span style="color: #666;">0.375</span>, <span style="color: #666;">0.875</span><span style="">&#41;</span><br />
<span style="">&#40;</span>-<span style="color: #666;">0.625</span>, <span style="color: #666;">0.875</span><span style="">&#41;</span></code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2><a name="wordlist"></a>Wordlists</h2>
<p>The <span class="inline_code">patten.en</span> module includes a number of general-purpose word lists:</p>
<table class="border">
<tbody>
<tr>
<td><span class="smallcaps">List</span></td>
<td><span class="smallcaps">Description</span></td>
<td style="text-align: center;"><span class="smallcaps">Size</span></td>
<td><span class="smallcaps">Example</span></td>
</tr>
<tr>
<td><span class="inline_code">ACADEMIC</span></td>
<td>English academic words</td>
<td style="text-align: center;">500</td>
<td><em>criterion</em>, <em>proportionally</em>, <em>research</em></td>
</tr>
<tr>
<td><span class="inline_code">BASIC</span></td>
<td>English basic words</td>
<td style="text-align: center;">1,000</td>
<td><em>chicken</em>, <em>pain</em>, <em>road</em></td>
</tr>
<tr>
<td><span class="inline_code">PROFANITY</span></td>
<td>English swear words</td>
<td style="text-align: center;">350</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><span class="inline_code">TIME</span></td>
<td>English time &amp; date words</td>
<td style="text-align: center;">100</td>
<td><em>Christmas</em>, <em>past</em>, <em>saturday</em></td>
</tr>
</tbody>
</table>
<p><span class="example"><span class="geshifilter"><code class="python geshifilter-python"><span style="">&gt;&gt;&gt;</span> <span style="color: #28334f; font-weight: bold;">from</span> pattern.<span style="">en</span>.<span style="">wordlist</span> <span style="color: #28334f; font-weight: bold;">import</span> ACADEMIC<br />
<span style="">&gt;&gt;&gt;</span> words = <span style="color: #4a587c;">open</span><span style="">&#40;</span><span style="color: #657a8a;">&quot;paper.txt&quot;</span><span style="">&#41;</span>.<span style="">read</span><span style="">&#40;</span><span style="">&#41;</span>.<span style="">split</span><span style="">&#40;</span><span style="color: #657a8a;">&quot; &quot;</span><span style="">&#41;</span><br />
<span style="">&gt;&gt;&gt;</span> words = <span style="">&#91;</span>w <span style="color: #28334f; font-weight: bold;">for</span> w <span style="color: #28334f; font-weight: bold;">in</span> words <span style="color: #28334f; font-weight: bold;">if</span> w <span style="color: #28334f; font-weight: bold;">not</span> <span style="color: #28334f; font-weight: bold;">in</span> ACADEMIC<span style="">&#93;</span> </code></span></span></p>
<p>&nbsp;</p>
<hr />
<h2>See also</h2>
<ul>
<li><a href="http://www.clips.ua.ac.be/pages/MBSP" target="_blank">MBSP</a> (GPL): r<span>obust parser using a memory-based learning approach, in Python.</span></li>
<li><span><a href="http://www.nltk.org/" target="_blank">NLTK</a> (Apache): f</span><span>ull natural language processing toolkit for Python.</span></li>
</ul>
</div>
</div></div>
        </div>
    </div>
    </div>
    </div>
    </div>
    </div>
</body>
</html>